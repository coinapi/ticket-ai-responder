




Market Data API | CoinAPI.io Documentation









Skip to main contentMarket DataEMSFlat FilesNAASGeneralGitHubSearchGet a free API KeyMarket Data APIAuthenticationAPI limits and billingREST APIWebSocket API V1WebSocket API DSJSON RPCFIX APIHow-to guidesPerformance Testing GuideMarket Data APIOn this pageMarket Data - Starter Guide Welcome to the CoinAPI developer documentation.
This document should contain all the information required to properly implement applications using our API.Overview of the APIs​3 main interfaces can be used to access CoinAPI:APIDataCommunicationDescriptionRESTfulLive and HistoricalRequest-responseStateless API provides the widest range of data, not capable of streaming, only pooling.WebSocket V1LivePublish-subscribeStateful API providing streaming of real-time market data. Using a single connection, clients are able to subscribe to multiple data sources.WebSocket DSLivePublish-subscribeNewly introduced, stateful API providing streaming of real-time market data with direct connections to each data source for optimized performance and reliability.FIXLivePublish-subscribeStateful API providing streaming of real-time market data, widely adopted by the finance industry. Using single connection client is able to subscribe to multiple data sources.Comparison: REST vs. Streaming Protocols (WebSocket & FIX)​Understanding the differences between REST and streaming protocols like WebSocket and FIX is essential for developers when designing and implementing financial applications. Here's a detailed comparison to guide your choice.FeatureREST APIWebSocket & FIXCommunication ModelRequest-response model, where the client sends a request and the server respondsContinuous, bidirectional communication allowing for real-time data streamingUse CaseIdeal for operations that do not require real-time updates, such as retrieving historical dataSuited for applications requiring real-time market data updates and trading operationsComplexityGenerally simpler to implement due to the stateless nature of HTTP requestsMore complex due to the need for handling continuous connections and real-time data managementData FreshnessData is only as fresh as the last request made by the clientData is continuously updated in real-time, providing the latest market informationScalabilityCan be more easily scaled using standard web infrastructureScaling requires careful management of connection resources and data throughputLatencyHigher latency due to the overhead of making HTTP requestsLower latency, optimized for real-time data delivery and trading activitiesState ManagementStateless, with each request being independentStateful, maintaining a continuous connection stateKey Takeaways​REST API is straightforward and effective for operations that can tolerate the latency inherent in the request-response model. It's widely used for accessing historical data, account management, and other non-time-sensitive operations.WebSocket & FIX are tailored for real-time applications, such as live market data feeds, trading platforms, and other scenarios where immediate data access is crucial. They offer lower latency and continuous data streams but come with added complexity in implementation and resource management.Choosing between REST and streaming protocols depends on your application's specific needs regarding data freshness, real-time updates, and the complexity you're prepared to manage.Comparison: WebSocket APIs vs. FIX API​Understanding the differences between WebSocket APIs (both V1 and DS) and the FIX API is crucial for developers and financial institutions looking to integrate real-time market data and trading capabilities. Here's a detailed comparison to guide your choice.FeatureWebSocket APIsFIX APIProtocol NaturePublish-subscribe model, designed for real-time data streamingSession-based protocol, widely used for trading and order managementUse CaseBest suited for applications requiring real-time market data updatesPrimarily used for trading, order submission, and execution reportsComplexityRelatively simple to implement and useMore complex due to its extensive use in trading operationsData TypesPrimarily focused on market data (quotes, trades, book data)Supports a wide range of financial information including order entries, executions, and market dataLatencyLow latency, especially with WebSocket DS API optimized for high-frequency dataGenerally low latency, with performance depending on the implementation and network infrastructureReliabilityHigh reliability with TCP-based delivery ensuring message order and integrityExtremely high reliability and considered the industry standard for trading activitiesAuthorizationHTTP based authorization methodsUses session-based logins with possible additional security measuresFlexibilityHigh flexibility in subscribing to specific data types and exchangesHigh degree of customization and control over trading operations and data exchangeKey Takeaways​WebSocket APIs are ideal for applications that require efficient, real-time access to market data. They offer simplicity in implementation and flexibility in data subscription, making them suitable for a wide range of applications beyond trading, such as analytics and monitoring tools.FIX API is the go-to protocol for trading operations, offering robustness, reliability, and a wide range of functionalities tailored to the needs of traders and financial institutions. Its complexity and capabilities make it the standard for order management and execution in the financial industry.Choosing between WebSocket APIs and the FIX API depends on your specific requirements, whether you're focusing on real-time data streaming for various applications or engaging in complex trading operations.Comparison: WebSocket V1 vs. WebSocket DS API​When choosing between WebSocket V1 and WebSocket DS API, it's important to understand their key differences and how they cater to different needs. Here's a comparison to help you decide which API suits your project requirements better.FeatureWebSocket V1 APIWebSocket DS APIConnection TypePossible to acquire the data from multiple data sources using single connectionSeparate data sources need separate connectionRoutingGeoDNS for regional routing to nearest infrastructureOptimized DNS for more direct connection per specific data sourceData typestrade, quote, orderbooks, ohlcv, exchange rates, metadatatrade, quote, orderbooksAuthorizationIn protocol authorization, query-string, URL path, header, or JWTquery-string, URL path, header, or JWTSymbol FilteringFlexible symbol filteringRequires precise symbol identifiers for improved data accuracySymbologyCoinAPI Symbol identifiersCoinAPI or Exchange symbols identifiersKey Takeaways​WebSocket V1 is versatile and user-friendly, making it suitable for a wide range of applications that require real-time market data.WebSocket DS API is tailored for scenarios demanding high data volumes and low latency, such as high-frequency trading platforms. Its direct routing and exchange-specific connections provide a more efficient data stream with reduced latency.Choosing the right API depends on your specific needs regarding data volume, latency sensitivity, and the complexity of your data subscription requirements. Both APIs continue to be supported, ensuring that you can select the one that best fits your project's needs.SDK​Our Software Development Kit (SDK) is available on GitHub at https://github.com/coinapi/coinapi-sdk.
If possible then we are strongly recommending using our tested libraries available on GitHub, rather than creating new ones.
However, if you decide to create your implementation or to change the existing one, then we encourage you to create a Pull Request to our main repository with the proposed changes,
we will able to include your code in our official repository for use by other users, effectively creating collaboration.In the repository, you can find libraries or examples for languages or environments like:PythonRMatlabC#C++.NETJavaRubyGoJavaScriptTypeScriptNode.jsPHPHaskellObjective-CSwiftSecurity​The use of encryption is optional, and the decision to use it is on you. On the encrypted endpoints, we are using protocols that are considered the best security practices.tipYou should assume that we are always providing certificates signed by the Trusted Certification Authority.Standards and conventions​This section represents used standards and conventions across all documents and API's.infoThe keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this
document are to be interpreted as described in RFC 2119.Variables naming​All variables are named using the Snake case (or snake_case) naming convention.
This means that words are separated by a single underscore _ character, no spaces are used, and letters are lowercase.Asset codes​ISO 4217 currency code standard is used for fiat money identifications.
Cryptocurrency assets are identified using codes used by the general public or adopted by the majority of exchanges.Exchange codes​Exchange on our platform is identified by the specific exchange API and the matching engine behind it. When the example exchange has multiple separate APIs, e.g., for different products SPOT, OPTIONS, or to cover other regions, we will expose these symbols from these respective APIs on different exchange identifiers.  Below are examples of BINANCE (multiple APIs, multiple regions) and DERIBIT (single API, single region). A full listing of exchanges can be queried using the Market Data REST API.BINANCE Exchange IDsWebsiteDescriptionBINANCEhttps://www.binance.com/BinanceBINANCEDEXhttps://www.binance.org/Binance DEXBINANCEFTShttps://www.binance.com/Binance Futures (USDT/dapi)BINANCEFTSChttps://www.binance.com/Binance Futures (Coin/fapi)BINANCEFTSCUAThttps://www.binance.com/Binance Futures Testnet (Coin/fapi)BINANCEFTSUAThttps://www.binance.com/Binance Futures Testnet (USDT/dapi)BINANCEJEhttps://www.binance.je/Binance JerseyBINANCEJEXhttps://www.jex.com/enBinance JEXBINANCEKRhttps://www.binance.kr/Binance KoreaBINANCEOPTVhttps://www.binance.com/Binance Options Vanilla (vapi)BINANCEOPTVUAThttps://www.binance.com/Binance Options Vanilla Testnet (vapi)BINANCEUAThttps://www.binance.com/Binance TestnetBINANCEUGhttps://www.binance.co.ug/Binance UgandaBINANCEUShttps://www.binance.us/Binance USDERIBIT Exchange IDsWebsiteDescriptionDERIBIThttps://www.deribit.com/DeribitNumbers precision​Numbers in our platform can have a maximum of 19 digits overall, but no more than 9 decimal places. In cases when the number represents aggregate value then we allow 38 digits overall, but still no more than 9 decimal places.Time​For all input and output time values ISO 8601 standard is used.Format specifierDescriptionyyyyThe year is a four-digit number.MMThe month, from 01 through 12.ddThe day of the month, from 01 through 31.HHThe hour, using a 24-hour clock from 00 to 23.mmThe minute, from 00 through 59.ssThe second, from 00 through 59.fffThe milliseconds in a date and time value.fffffffThe ten-millionths of a second in a date and time value.Input time values are parsed using the following formats as far as possible:yyyy-MM-ddTHH:mm:ss.fffffffyyyy-MM-ddTHH:mm:ss.fffyyyy-MM-ddTHH:mm:ssyyyy-MM-ddTHH:mmyyyy-MM-ddTHHyyyy-MM-ddyyyyMMddTHHmmssfffffffyyyyMMddTHHmmssfffyyyyMMddTHHmmssyyyyMMddTHHmmyyyyMMddTHHyyyyMMddinfoWhen time zone information is not supplied, we will assume the UTC zone.Output time values are formatted using the following patterns:yyyy-MM-ddTHH:mm:ss.fffffffZyyyy-MM-ddinfoAll time values we provide are UTC zones. Do not assume otherwise.Was this section helpful?12345NextAuthenticationOverview of the APIsComparison: REST vs. Streaming Protocols (WebSocket & FIX)Key TakeawaysComparison: WebSocket APIs vs. FIX APIKey TakeawaysComparison: WebSocket V1 vs. WebSocket DS APIKey TakeawaysSDKSecurityStandards and conventionsVariables namingAsset codesExchange codesNumbers precisionTimeCopyright © 2024 COINAPI LTD or its affiliates. All rights reserved.



(https://docs.coinapi.io/market-data)